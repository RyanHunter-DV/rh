class Config ##{
public
	attr_accessor :block;
	attr_accessor :name;
	attr_accessor :simulator;
	attr_accessor :insts;
	attr_accessor :paths;

	attr :filelist;
	attr :compopts;
	attr :elabopts;
	attr :simopts;
	attr :top;

	def initialize n ##{{{
		@name     = n;
		@block    = nil;
		@simulator= nil;
		@insts    = [];
		@filelist = n+'.list';
		@top      = 'top'; ## default
		initConfigPaths;
		initSimulatorOpts;
	end ##}}}

	def filelist l=nil ##{
		if l==nil
			return @filelist;
		else
			@filelist = l.to_s;
		end
	end ##}
	def complog f ##{{{
		@simulator.log :compile,f
	end ##}}}
	def worklib n ##{{{
		@simulator.worklib n.to_s;
	end ##}}}

	def compopts ##{{{
		t = @simulator.name.to_sym;
		return @compopts[t];
	end ##}}}
	def elabopts ##{{{
		t = @simulator.name.to_sym;
		return @elabopts[t];
	end ##}}}
	def simopts ##{{{
		t = @simulator.name.to_sym;
		return @simopts[t];
	end ##}}}

	def tool t ##{{{
		setupSimulator t.to_sym;
	end ##}}}

	def need n ##{{{
		##puts "from need, to find:#{n}"
		c = ComponentPool.find n;
		unless c==nil
			c.elaborate;
			@insts << c;
		end
	end ##}}}

	def compopt t,*opts ##{{{
		t=t.to_sym;
		opts.each do |opt|
			@compopts[t] << opt;
		end
	end ##}}}
	def elabopt t,*opts ##{{{
		t=t.to_sym;
		opts.each do |opt|
			@elabopts[t] << opt;
		end
	end ##}}}
	def simopt t,*opts ##{{{
		t=t.to_sym;
		opts.each do |opt|
			@simopts[t] << opt;
		end
	end ##}}}
	def top tn ##{
		@top = tn.to_s;
	end ##}

	def elaborate ##{
		## called after the instance of manual block
		@simulator.worktop = @top;
	end ##}

	def storeAndExecuteLocalBlock &block ##{{{
		@block = block;
		self.instance_eval &block;
	end ##}}}

private

	def initConfigPaths ##{{{
		@paths    = {};
		@paths[:out]      = $outAnchor;
		@paths[:component]= $outAnchor+'/components';
		@paths[:config]   = $outAnchor+'/config';
		@paths[:root]     = @paths[:config]+'/'+@name.to_s;
		@paths[:build]    = @paths[:root]+'/build';
		@paths[:sim]      = @paths[:root]+'/sim';
	end ##}}}

	def initSimulatorOpts ##{{{
		@compopts= {};
		@elabopts= {};
		@simopts = {};
		@compopts[:vcs]= [];
		@compopts[:xlm]= [];
		@elabopts[:vcs]= [];
		@elabopts[:xlm]= [];
		@simopts[:vcs] = [];
		@simopts[:xlm] = [];
	end ##}}}

	def setupSimulator t ##{{{
		@simulator = Simulator.new(t,@paths[:build],@paths[:sim]);
	end ##}}}
end ##}

module ConfigPool ##{
	@pool = {};

	def self.register c ##{{{{
		##puts "register config: #{c}"
		@pool[c.name.to_sym] = c;
	end ##}}}

	def self.find n ##{{{
		return @pool[n.to_sym] if @pool.has_key?(n.to_sym);
		return nil;
	end ##}}}

	def self.createAndRegisterNewConfig n ##{{{
		n = n.to_s;
		c = Config.new(n);
		self.register c;
		return c;
	end ##}}}
end ##}

def config n,opts={},&block ##{
	n = n.to_s;
	if ConfigPool.find n
		$stderr.puts "Error, multiple definition of one config is not allowed"
		return;
	end

	c = ConfigPool.createAndRegisterNewConfig(n);

	if opts.has_key?(:extends) ##{
		parents = opts[:extends];
		parents = [parents] unless parents.is_a?(Array);
		parents.each do |p| ##{
			po = ConfigPool.find p.to_s;
			if po==nil
				$stderr.puts "Error, parent config(#{p}) not exists"
				return;
			end
			c.instance_eval &po.block;
		end ##}
	end ##}
	if opts.has_key?(:tool)
		c.tool opts[:tool];
	else
		c.tool :xlm; ## default
	end
	c.storeAndExecuteLocalBlock &block;
	c.elaborate;
end ##}
