class Publisher ##{
	attr :simulator;
	attr :root;
	attr :paths;

	def initialize r ##{
		@root = r;
		simulator(:xlm); ## default
		@paths={};
		@paths[:out]=File.join(@root,'out');
	end ##}

	##
	def publish co,t ##{
		clists = [];
		__buildCommonPaths;
		co.insts.each_pair do |n,c| ##{
			__buildComponentPath n;
			__publishComponentFiles(n,c,t);
			lists = __publishComponentFilelist(c);
			clists.append(*lists);
		end ##}
		__publishConfigPaths(co.name);
		__publishConfigFilelist(clists);
	end ##}

	def buildSimDir t,lib ##{
		@paths[t.name.to_sym] = File.join(@paths[:sim],t.name.to_s);
		Shell.makedir @paths[t.name.to_sym];
		__buildXceliumDefaultLib(t.name,lib) if @simulator==:xlm;
	end ##}

	def __buildXceliumDefaultLib tn,lib ##{
		Shell.makedir File.join(@paths[tn.to_sym],lib.to_s);
		fh = File.open(@paths[tn.to_sym]+'/cds.lib','w');
		fh.write('DEFINE '+lib+' ./'+lib);
		fh.close();
		fh = File.open(@paths[tn.to_sym]+'/hdl.var','w');
		fh.write('DEFINE WORK '+lib);
		fh.close();
		return;
	end ##}

	def selectTool s=:xlm,t=:compile ##{
		tool = '';
		case s
			when :xlm
				if t==:compile
					tool='XMVLOG';
				elsif t==:elaborate
					tool='XMELAB';
				else
					tool='XMSIM';
				end
			when :vcs
				puts "not supported yet"
		end
		return tool;
	end ##}
	## c is src object, for compile/elaborate, c is config
	## for sim, c is test
	def generateCommand c,s=:xlm,t=:compile,*extras ##{
		opts = [];
		cmd  = '';
		file = '';
		case t
			when :compile
				opts = c.compopts(s);
				opts.append("-f #{@paths[:build]}/filelist");
				cmd  = selectTool(s,t);
				file = File.join(@paths[:build],'compileCommand');
			when :elaborate
				opts = c.elabopts(s);
				cmd  = selectTool(s,t);
				file = File.join(@paths[:build],'elaborateCommand');
			when :sim
				opts = c.simopts(s);
				cmd  = selectTool(s,t);
				file = File.join(@paths[c.name.to_sym],'simCommand');
			else
				puts "Error, type not available"
		end
		opts.insert(0,cmd);
		extras.each do |o|
			opts << o;
		end
		opts.uniq!;
		fh = File.open(file,'w');
		opts.each do |l|
			l+=' ';
			fh.write(l);
		end
		fh.close();
	end ##}

	def simulator s ##{
		@simulator = s;
	end ##}

private

	def __publishConfigFilelist clists ##{
		lcontents = [];
		clists.each do |n| ##{
			n=n.to_s;
			fh = File.open(n,'r');
			cnts = fh.readlines();
			fh.close();
			cnts.each do |l| ##{
				if l =~ /incdir/
					lcontents.insert(0,l);
				else
					lcontents.append(l);
				end
			end ##}
		end ##}
		fh = File.open(@paths[:build]+'/filelist','w');
		lcontents.each do |l|
			fh.write(l);
		end
		fh.close();
	end ##}

	def __publishConfigPaths n ##{
		n=n.to_s;
		@paths[:config] =File.join(@paths[:out],'config');
		@paths[n.to_sym]=File.join(@paths[:config],n);
		@paths[:build]  =File.join(@paths[n.to_sym],'build');
		@paths[:sim]    =File.join(@paths[n.to_sym],'sim');
		Shell.makedir(@paths[:config],@paths[n.to_sym],@paths[:build],@paths[:sim]);
	end ##}

	def replaceSrcToOutComponentPath n,f,t=:incdir ##{
		cpath = File.join(@paths[:out],n);
		if t==:incdir
			f.sub!(@root,cpath);
		else
			bn = File.basename(f);
			f = File.join(cpath,bn);
		end
		return f;
	end ##}

	def __publishComponentFilelist(c) ##{
		listnames = []
		cpath = File.join(@paths[:out],c.name.to_s);
		c.lists.each_pair do |k,l| ##{
			listname = File.join(cpath,k.to_s);
			listnames << listname;
			##puts "list: #{listname}"
			fh = File.open(listname,'w')
			l.incdirs.each do |inc| ##{
				inc=replaceSrcToOutComponentPath(c.name.to_s,inc);
				case (@simulator)
					when :xlm
						fh.write('-incdir '+inc+"\n");
					else
						puts "Error, unsupported simulator"
				end
			end ##}
			l.files.each do |f| ##{
				f=replaceSrcToOutComponentPath(c.name.to_s,f,:file);
				fh.write(f+"\n");
			end ##}
			fh.close();
		end ##}
		return listnames;
	end ##}

	def __copyOneFile(s,n) ##{
		n=n.to_s;
		s=s.to_s;
		t = File.join(@paths[:out],n);
		##puts "copy(#{s},#{t})"
		Shell.copy(s,t);
	end ##}

	def __publishComponentFiles(n,c,t) ##{
		c.lists.each_pair do |k,l|
			l.files.each do |f|
				if t==:copy
					__copyOneFile(f,n);
				end
			end
		end
	end ##}

	def __buildComponentPath n ##{
		n = n.to_s;
		p = File.join(@paths[:out],n);
		##puts "building component path: #{p}"
		Shell.makedir(p);
	end ##}

	def __buildCommonPaths ##{
		@paths[:logs] = File.join(@paths[:out],'logs');
		Shell.makedir @paths[:out],@paths[:logs];
	end ##}


end ##}
