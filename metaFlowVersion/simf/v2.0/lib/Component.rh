rhload 'lib/Shell';

class Filelist ##{
	attr_accessor :incdirs;
	attr_accessor :files;

	def initialize ##{
		@incdirs = [];
		@files   = [];
	end ##}

	def incdir d ##{
		if Dir.exists?(d)
			@incdirs << d;
		else
			puts "Error, #{d} not a valid dir"
		end
	end ##}

	## if a is array, then add all files
	## if a is a file, then add one file
	def add a ##{
		if a.is_a?(Array)
			a.each do |f|
				@files << f;
			end
		elsif a.is_a?(String)
			@files << a;
		else
			puts "unsupported type #{a.class}"
		end
	end ##}
end ##}

class Component ##{
	attr_accessor :name;
	attr_accessor :location;

	## opts type
	## *opts[:xlm] = [], support only xcelium
	attr_accessor :compopts;
	attr_accessor :elabopts;
	attr_accessor :simopts;

	attr :lists;

	def initialize n,src ##{
		@name     = n;
		@location = File.dirname(File.absolute_path(src));
		@lists={};
		@compopts={};
		@elabopts={};
		@simopts={};
	end ##}

	def createNewList n ##{
		nl = Filelist.new();
		## add incdir for first of the target list
		nl.incdir @location;
		@lists[n.to_s] = nl;
	end ##}

	def incset i,l ##{
		l = l.to_s;
		createNewList(l) unless @lists.has_key?(l.to_s);
		i = File.join(@location,i);
		@lists[l].incdir(i);
	end ##}

	def fileset f,l ##{
		createNewList(l) unless @lists.has_key?(l.to_s);
		fs = Shell.getAbsoluteFiles(f,@location);
		@lists[l.to_s].add(fs);
	end ##}

	## supports multiple opts
	def compopt t,*opts ##{
		t=t.to_sym;
		@compopts[t]=[] unless @compopts.has_key?(t)
		opts.each do |o|
			@compopts[t] << o;
		end
	end ##}

	def elabopt t,*opts ##{
		t=t.to_sym;
		@elabopts[t]=[] unless @elabopts.has_key?(t)
		opts.each do |o|
			@elabopts[t] << o;
		end
	end ##}
	def simopt t,*opts ##{
		t=t.to_sym;
		@simopts[t]=[] unless @simopts.has_key?(t)
		opts.each do |o|
			@simopts[t] << o;
		end
	end ##}


end ##}

module ComponentPool ##{

	@pool = {};

	def self.register c ##{
		@pool[c.name.to_sym] = c;
	end ##}

	def self.find n ##{
		n = n.to_sym;
		if @pool.has_key?(n)
			return @pool[n];
		else
			return nil;
		end
	end ##}

end ##}


def component n,&block ##{
	return unless block_given?
	sl = block.source_location;
	c = Component.new(n,sl[0]);
	c.instance_eval &block;
	ComponentPool.register c;
end ##}
